#+OPTIONS: toc:nil

* exec - Capture stderr in exec.Cmd.Run
=exex= provides syntactic sugar around exec.Cmd to easily run commands and capturing STDERR.

The standard library =exec= package contains a very useful API to execute commands, however, the [[https://pkg.go.dev/os/exec#Cmd.Run][exec.Cmd.Run]] and [[https://pkg.go.dev/os/exec#Cmd.Output][exec.Cmd.Output]] methods behave differently in the case of a failed execution.
In particular, =exec.Cmd.Run= will NOT populate =exec.ExitError.Stderr= in the case of failure, whereas =exec.Cmd.Output= will do.
While this is explicitly noted in the exec package documentation, it is a source of confusion even for experienced users.

Another issue with the standard library package is that if we use =exec.Cmd.Output= to only capture the error we will be incurring in unnecessary allocations because it uses a =bytes.Buffer= for capturing STDOUT, and also STDERR will be truncated.
The wrappers defined in this library do not have this peformance penalization nor truncate any output.

** Benchmarks

#+begin_src shell :results verbatim :exports both
go test -benchmem -bench=. -benchtime=1000x
#+end_src

#+RESULTS:
#+begin_example
goos: darwin
goarch: amd64
pkg: github.com/inkel/exex
cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz
BenchmarkCaptureStderr/stdlib-12         	    1000	   3252001 ns/op	   35571 B/op	      49 allocs/op
BenchmarkCaptureStderr/exex-12           	    1000	   3117107 ns/op	    2856 B/op	      39 allocs/op
BenchmarkRun-12                          	    1000	   3241472 ns/op	    2904 B/op	      39 allocs/op
BenchmarkRunContext-12                   	    1000	   3105753 ns/op	    3032 B/op	      41 allocs/op
BenchmarkRunCommand-12                   	    1000	   3132764 ns/op	    2904 B/op	      39 allocs/op
PASS
ok  	github.com/inkel/exex	16.105s
#+end_example

As you can see, the number of bytes and allocations per operation is drastically improved in =exex=.

A better comparison of the difference in performance can be done using [[https://pkg.go.dev/golang.org/x/perf/cmd/benchstat][benchstat]]:

#+begin_src shell :results no
# Generate benchmarks for stdlib
BENCHMARK=stdlib go test -benchmem -bench=CaptureStderr -benchtime=500x -count=10 > stdlib.txt

# Generate benchmarks for exex
BENCHMARK=exex go test -benchmem -bench=CaptureStderr -benchtime=500x -count=10 > exex.txt
#+end_src

#+begin_src shell :results verbatim :exports both
# Compare the results
benchstat stdlib.txt exex.txt
#+end_src

#+RESULTS:
: name              old time/op    new time/op    delta
: CaptureStderr-12    3.10ms ± 2%    3.11ms ± 2%     ~     (p=0.222 n=9+9)
:
: name              old alloc/op   new alloc/op   delta
: CaptureStderr-12    35.5kB ± 0%     2.9kB ± 2%  -91.91%  (p=0.000 n=9+10)
:
: name              old allocs/op  new allocs/op  delta
: CaptureStderr-12      49.0 ± 0%      39.0 ± 0%  -20.41%  (p=0.000 n=10+10)

If an image is worth a thousand words, how much worth is a benchmark?

** License
See [[./LICENSE][LICENSE]], but basically, MIT.
